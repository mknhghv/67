-- 零中心 - 修復版（透視 + 速度完整加入 + 怪物預設開 + 修復視角卡死 & 報錯問題）
-- 已徹底修復 RunService 連接洩漏、透視記憶體洩漏、速度導致相機卡死的問題

local old = hookmetamethod(game:GetService("StarterGui"), "__namecall", newcclosure(function(self, ...)
    local method = getnamecallmethod()
    local args = {...}
    if method == "SetCore" and args[1] == "SendNotification" then
        local options = args[2]
        if type(options) == "table" and (tostring(options.Title) == "零脚本" or tostring(options.Text):find("小轩")) then
            local modified = table.clone(options)
            modified.Text = "修復版載入成功"
            return old(self, modified)
        end
    end
    return old(self, ...)
end))

-- 關閉相機抖動（安全方式）
pcall(function()
    local main = require(game:GetService("ReplicatedStorage").Util.CameraShaker.Main)
    local nilfunc = function() end
    for k,v in pairs(main) do if type(v) == "function" then main[k] = nilfunc end end
end)

game:GetService("StarterGui"):SetCore("SendNotification",{Title="零腳本", Text="修復版載入，按Insert/RightShift開UI", Duration=5})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- 最新穩定Orion源
local OrionLib = loadstring(game:HttpGet('https://raw.githubusercontent.com/jensonhirst/Orion/main/source'))()

local Window = OrionLib:MakeWindow({
    Name = "零中心 - 修復版",
    HidePremium = false,
    SaveConfig = false,
    ConfigFolder = "LingFix2026"
})

-- 強制顯示UI
task.spawn(function()
    wait(0.5)
    OrionLib:Init()
    OrionLib:MakeNotification({
        Name = "零腳本",
        Content = "修復完成！透視+速度正常，不會卡視角",
        Time = 6
    })
end)

local Tab1 = Window:MakeTab({Name = "秒殺", Icon = "rbxassetid://7734068321"})
local Tab2 = Window:MakeTab({Name = "透視", Icon = "rbxassetid://7734068321"})
local Tab3 = Window:MakeTab({Name = "速度", Icon = "rbxassetid://7734068321"})

-- ==================== 秒殺（怪物預設開） ====================
local Settings = {AutoClick = true, ClickDelay = 0.01}
_G.FastAttack = false

local function SafeWaitForChild(parent, childName)
    return pcall(function() return parent:WaitForChild(childName, 10) end) and parent:WaitForChild(childName, 10) or nil
end

local function CheckAndGetCoreComponents()
    local Remotes, Modules, Net, RegisterAttack, RegisterHit, Enemies
    while true do
        Remotes = SafeWaitForChild(ReplicatedStorage, "Remotes")
        Modules = SafeWaitForChild(ReplicatedStorage, "Modules")
        Net = Modules and SafeWaitForChild(Modules, "Net")
        RegisterAttack = Net and SafeWaitForChild(Net, "RE/RegisterAttack")
        RegisterHit = Net and SafeWaitForChild(Net, "RE/RegisterHit")
        Enemies = SafeWaitForChild(Workspace, "Enemies")
        if Remotes and Modules and Net and RegisterAttack and RegisterHit and Enemies then
            return Remotes, Net, RegisterAttack, RegisterHit, Enemies
        end
        task.wait(1)
    end
end

local function IsAlive(char)
    if not char then return false end
    local hum = char:FindFirstChildOfClass("Humanoid")
    return hum and hum.Health > 0
end

local function GetRandomValidPart(target)
    local hrp = target:FindFirstChild("HumanoidRootPart")
    if hrp then return hrp end
    return target:FindFirstChildWhichIsA("BasePart")
end

local FastAttack = {
    Distance = 100000,
    attackMobs = true,     -- 怪物預設開
    attackPlayers = true,
    IsRunning = false
}

local function ProcessEnemies(OthersEnemies)
    if not FastAttack.attackMobs then return nil end
    local EnemiesFolder = Workspace:FindFirstChild("Enemies")
    if not EnemiesFolder then return nil end
    local BasePart = nil
    for _, Enemy in EnemiesFolder:GetChildren() do
        if IsAlive(Enemy) then
            local part = GetRandomValidPart(Enemy)
            if part and LocalPlayer:DistanceFromCharacter(part.Position) < FastAttack.Distance then
                table.insert(OthersEnemies, {Enemy, part})
                BasePart = part
            end
        end
    end
    return BasePart
end

local function ProcessPlayers(OthersEnemies)
    if not FastAttack.attackPlayers then return nil end
    local BasePart = nil
    for _, p in Players:GetPlayers() do
        if p ~= LocalPlayer and IsAlive(p.Character) then
            local part = GetRandomValidPart(p.Character)
            if part and LocalPlayer:DistanceFromCharacter(part.Position) < FastAttack.Distance then
                table.insert(OthersEnemies, {p.Character, part})
                BasePart = part
            end
        end
    end
    return BasePart
end

function FastAttack:AttackNearest()
    if not self.IsRunning then return end
    local OthersEnemies = {}
    ProcessEnemies(OthersEnemies)
    ProcessPlayers(OthersEnemies)
    if #OthersEnemies > 0 then
        local _, _, ra, rh = CheckAndGetCoreComponents()
        if ra and rh then
            ra:FireServer(Settings.ClickDelay)
            rh:FireServer(OthersEnemies[1][2], OthersEnemies)
        end
    end
end

task.spawn(function()
    while true do
        task.wait(Settings.ClickDelay)
        if FastAttack.IsRunning then
            FastAttack:AttackNearest()
        end
    end
end)

-- 秒殺UI
Tab1:AddToggle({Name = "秒殺總開關", Default = false, Callback = function(v) FastAttack.IsRunning = v end})
Tab1:AddToggle({Name = "攻擊怪物", Default = true, Callback = function(v) FastAttack.attackMobs = v end})
Tab1:AddToggle({Name = "攻擊玩家", Default = true, Callback = function(v) FastAttack.attackPlayers = v end})
Tab1:AddTextbox({Name = "範圍", Default = "100000", Callback = function(v) FastAttack.Distance = tonumber(v) or 100000 end})
Tab1:AddTextbox({Name = "攻速延遲", Default = "0.01", Callback = function(v) Settings.ClickDelay = tonumber(v) or 0.01 end})

-- ==================== 透視（完整 + 防洩漏修復） ====================
local ESPConfig = {MainSwitch = false, ShowTracer = true, ShowBox = true}
local ESPObjects = {}

local function CleanupESP(player)
    local data = ESPObjects[player.UserId]
    if data then
        if data.Box then data.Box:Remove() end
        if data.Tracer then data.Tracer:Remove() end
        if data.Conn then data.Conn:Disconnect() end
        ESPObjects[player.UserId] = nil
    end
end

local function CreateESP(player)
    if player == LocalPlayer or not player.Character then return end
    CleanupESP(player)

    local box = Drawing.new("Square")
    box.Thickness = 2
    box.Filled = false
    box.Color = Color3.new(1,0,0)
    box.Transparency = 0.8
    box.Visible = false

    local tracer = Drawing.new("Line")
    tracer.Thickness = 2
    tracer.Color = Color3.new(1,0,0)
    tracer.Transparency = 0.8
    tracer.Visible = false

    local conn = RunService.RenderStepped:Connect(function()
        local char = player.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") or not ESPConfig.MainSwitch then
            box.Visible = false
            tracer.Visible = false
            return
        end

        local root = char.HumanoidRootPart
        local pos, onScreen = Camera:WorldToViewportPoint(root.Position)
        if onScreen then
            -- Box
            if ESPConfig.ShowBox then
                local size = (Camera:WorldToViewportPoint(root.Position + Vector3.new(0,6,0)).Y - Camera:WorldToViewportPoint(root.Position - Vector3.new(0,3,0)).Y) / 2
                box.Size = Vector2.new(size * 2, size * 3)
                box.Position = Vector2.new(pos.X - box.Size.X/2, pos.Y - box.Size.Y/2)
                box.Visible = true
            else
                box.Visible = false
            end

            -- Tracer
            if ESPConfig.ShowTracer then
                tracer.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
                tracer.To = Vector2.new(pos.X, pos.Y)
                tracer.Visible = true
            else
                tracer.Visible = false
            end
        else
            box.Visible = false
            tracer.Visible = false
        end
    end)

    ESPObjects[player.UserId] = {Box = box, Tracer = tracer, Conn = conn}
end

local function RefreshESP()
    for _, p in Players:GetPlayers() do
        if p ~= LocalPlayer then CreateESP(p) end
    end
end

Players.PlayerAdded:Connect(function(p)
    p.CharacterAdded:Connect(function() task.wait(1); CreateESP(p) end)
end)
Players.PlayerRemoving:Connect(CleanupESP)

-- 透視UI
Tab2:AddToggle({Name = "透視總開關", Default = false, Callback = function(v) ESPConfig.MainSwitch = v; RefreshESP() end})
Tab2:AddToggle({Name = "方框", Default = true, Callback = function(v) ESPConfig.ShowBox = v end})
Tab2:AddToggle({Name = "射線", Default = true, Callback = function(v) ESPConfig.ShowTracer = v end})

-- ==================== 速度（修復視角卡死關鍵） ====================
local SpeedEnabled = false
local SpeedValue = 50
local SpeedConn = nil

Tab3:AddTextbox({Name = "速度數值", Default = "50", Callback = function(v) SpeedValue = tonumber(v) or 50 end})
Tab3:AddToggle({
    Name = "速度開關",
    Default = false,
    Callback = function(state)
        SpeedEnabled = state
        if SpeedConn then SpeedConn:Disconnect() SpeedConn = nil end
        if state then
            SpeedConn = RunService.Heartbeat:Connect(function()
                local char = LocalPlayer.Character
                if char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChild("Humanoid") then
                    local hum = char.Humanoid
                    if hum.MoveDirection.Magnitude > 0 then
                        char.HumanoidRootPart.Velocity = hum.MoveDirection * SpeedValue * 1.8  -- 改用Velocity，不影響相機
                    end
                end
            end)
        end
    end
})

-- 角色重生時重置
LocalPlayer.CharacterAdded:Connect(function()
    if SpeedConn then SpeedConn:Disconnect() SpeedConn = nil end
    if SpeedEnabled then
        task.wait(1)
        SpeedConn = RunService.Heartbeat:Connect(function()
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChild("Humanoid") then
                local hum = char.Humanoid
                if hum.MoveDirection.Magnitude > 0 then
                    char.HumanoidRootPart.Velocity = hum.MoveDirection * SpeedValue * 1.8
                end
            end
        end)
    end
end)

OrionLib:Init()
